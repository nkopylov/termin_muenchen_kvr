import os
import time
import asyncio
import logging
import sqlite3
import json
from datetime import datetime, timedelta
from pathlib import Path
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, CallbackContext
from termin_tracker import get_fresh_captcha_token, get_available_days
from services_manager import categorize_services, get_service_info, get_category_for_service

# Load environment variables from .env file
load_dotenv()

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Configuration
OFFICE_ID = "10461"
SERVICE_ID = "10339028"
CHECK_INTERVAL = 120  # seconds
BOOKING_URL = "https://stadt.muenchen.de/buergerservice/terminvereinbarung.html#/services/10339028/locations/10461"
DB_FILE = os.getenv("DB_FILE", "bot_data.db")

# Global stats
stats = {
    'total_checks': 0,
    'successful_checks': 0,
    'failed_checks': 0,
    'appointments_found_count': 0,
    'last_check_time': None,
    'last_success_time': None,
    'bot_start_time': None
}

# Store the captcha token and its expiry time
captcha_token = None
token_expires_at = 0


def init_database():
    """Initialize SQLite database"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Create users table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            subscribed_at TEXT,
            start_date TEXT,
            end_date TEXT,
            language TEXT DEFAULT 'de'
        )
    ''')

    # Create service_subscriptions table (new)
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS service_subscriptions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            service_id INTEGER,
            office_id INTEGER,
            subscribed_at TEXT,
            UNIQUE(user_id, service_id, office_id),
            FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
        )
    ''')

    # Create appointment_logs table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS appointment_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            found_at TEXT,
            service_id INTEGER,
            office_id INTEGER,
            data TEXT
        )
    ''')

    # Migration: Add language column if it doesn't exist
    try:
        cursor.execute("SELECT language FROM users LIMIT 1")
    except sqlite3.OperationalError:
        logger.info("Migrating database: adding language column to users table")
        cursor.execute("ALTER TABLE users ADD COLUMN language TEXT DEFAULT 'de'")
        conn.commit()
        logger.info("Migration completed: language column added")

    conn.commit()
    conn.close()


def load_subscribers():
    """Load subscribers from database"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('SELECT user_id, start_date, end_date FROM users')
    users = {}
    for row in cursor.fetchall():
        users[row[0]] = {
            'start_date': row[1],
            'end_date': row[2]
        }
    conn.close()
    return users


def save_subscriber(user_id, username, start_date, end_date):
    """Save or update subscriber in database"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        INSERT OR REPLACE INTO users (user_id, username, subscribed_at, start_date, end_date)
        VALUES (?, ?, ?, ?, ?)
    ''', (user_id, username, datetime.now().isoformat(), start_date, end_date))
    conn.commit()
    conn.close()


def remove_subscriber(user_id):
    """Remove subscriber from database"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('DELETE FROM users WHERE user_id = ?', (user_id,))
    cursor.execute('DELETE FROM service_subscriptions WHERE user_id = ?', (user_id,))
    conn.commit()
    conn.close()


def add_service_subscription(user_id, service_id, office_id=10461):
    """Add a service subscription for a user"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    try:
        cursor.execute('''
            INSERT OR IGNORE INTO service_subscriptions (user_id, service_id, office_id, subscribed_at)
            VALUES (?, ?, ?, ?)
        ''', (user_id, service_id, office_id, datetime.now().isoformat()))
        conn.commit()
        return True
    except Exception as e:
        logger.error(f"Error adding service subscription: {e}")
        return False
    finally:
        conn.close()


def remove_service_subscription(user_id, service_id, office_id=10461):
    """Remove a service subscription"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        DELETE FROM service_subscriptions
        WHERE user_id = ? AND service_id = ? AND office_id = ?
    ''', (user_id, service_id, office_id))
    conn.commit()
    conn.close()


def get_user_subscriptions(user_id):
    """Get all service subscriptions for a user"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        SELECT service_id, office_id, subscribed_at
        FROM service_subscriptions
        WHERE user_id = ?
    ''', (user_id,))
    subscriptions = cursor.fetchall()
    conn.close()
    return [{'service_id': row[0], 'office_id': row[1], 'subscribed_at': row[2]} for row in subscriptions]


def get_all_service_subscriptions():
    """Get all service subscriptions grouped by service/office"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        SELECT user_id, service_id, office_id
        FROM service_subscriptions
    ''')
    subscriptions = cursor.fetchall()
    conn.close()

    # Group by service_id and office_id
    grouped = {}
    for user_id, service_id, office_id in subscriptions:
        key = f"{service_id}_{office_id}"
        if key not in grouped:
            grouped[key] = []
        grouped[key].append(user_id)

    return grouped


def get_user_language(user_id: int) -> str:
    """Get user's preferred language"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('SELECT language FROM users WHERE user_id = ?', (user_id,))
    result = cursor.fetchone()
    conn.close()
    return result[0] if result and result[0] else 'de'


def set_user_language(user_id: int, language: str):
    """Set user's preferred language"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        UPDATE users SET language = ? WHERE user_id = ?
    ''', (language, user_id))
    conn.commit()
    conn.close()


def log_appointment_found(data):
    """Log when appointments are found"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO appointment_logs (found_at, data)
        VALUES (?, ?)
    ''', (datetime.now().isoformat(), json.dumps(data)))
    conn.commit()
    conn.close()


def get_user_date_range(user_id, subscribers):
    """Get date range for specific user or default"""
    if user_id in subscribers and subscribers[user_id]['start_date']:
        return subscribers[user_id]['start_date'], subscribers[user_id]['end_date']

    # Default: today to 6 months ahead
    today = datetime.now()
    end_date = today + timedelta(days=180)
    return today.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d")


def format_available_appointments(data):
    """Parse and format available appointment dates and times"""
    appointments_text = ""

    try:
        if isinstance(data, list):
            # List of available days
            for day in data[:5]:  # Show first 5 days
                appointments_text += f"üìÖ {day}\n"
        elif isinstance(data, dict):
            # Check for various response formats
            if 'data' in data and isinstance(data['data'], list):
                for item in data['data'][:5]:
                    if 'date' in item:
                        date_str = item['date']
                        time_str = item.get('time', '')
                        appointments_text += f"üìÖ {date_str}"
                        if time_str:
                            appointments_text += f" at {time_str}"
                        appointments_text += "\n"
            elif 'availableDays' in data:
                for day in data['availableDays'][:5]:
                    appointments_text += f"üìÖ {day}\n"
    except Exception as e:
        logger.warning(f"Could not parse appointment details: {e}")

    return appointments_text if appointments_text else ""


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle the /start command - subscribe user to notifications"""
    user_id = update.effective_user.id
    username = update.effective_user.username or update.effective_user.first_name

    subscribers = load_subscribers()

    # Default date range
    today = datetime.now()
    end_date = today + timedelta(days=180)
    start_date = today.strftime("%Y-%m-%d")
    end_date_str = end_date.strftime("%Y-%m-%d")

    if user_id in subscribers:
        await update.message.reply_text(
            "‚úÖ You are already subscribed to Munich appointment notifications!\n\n"
            f"I'll notify you when appointments become available.\n"
            f"Checking every {CHECK_INTERVAL // 60} minutes.\n\n"
            "Use /setdates to customize your date range."
        )
    else:
        save_subscriber(user_id, username, start_date, end_date_str)
        await update.message.reply_text(
            "‚úÖ Successfully subscribed to Munich appointment notifications!\n\n"
            f"I'll check for available appointments every {CHECK_INTERVAL // 60} minutes "
            f"and notify you immediately when slots become available.\n\n"
            f"Service: Notfalltermin Ausl√§nderbeh√∂rde\n"
            f"Office: M√ºnchen\n"
            f"Date range: {start_date} to {end_date_str}\n\n"
            "Commands:\n"
            "/setdates - Customize your date range\n"
            "/stop - Unsubscribe\n"
            "/status - Check your status\n"
            "/stats - View bot statistics"
        )
        logger.info(f"User {user_id} ({username}) subscribed")


async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle the /stop command - unsubscribe user from notifications"""
    user_id = update.effective_user.id
    subscribers = load_subscribers()

    if user_id in subscribers:
        remove_subscriber(user_id)
        await update.message.reply_text(
            "‚ùå Unsubscribed from appointment notifications.\n\n"
            "Use /start to subscribe again."
        )
        logger.info(f"User {user_id} unsubscribed")
    else:
        await update.message.reply_text(
            "You are not currently subscribed.\n\n"
            "Use /start to subscribe to notifications."
        )


async def setdates(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle the /setdates command - allow users to set custom date range"""
    user_id = update.effective_user.id
    subscribers = load_subscribers()

    if user_id not in subscribers:
        await update.message.reply_text(
            "You need to subscribe first using /start"
        )
        return

    # Parse arguments: /setdates YYYY-MM-DD YYYY-MM-DD
    if len(context.args) != 2:
        await update.message.reply_text(
            "Usage: /setdates START_DATE END_DATE\n\n"
            "Example: /setdates 2025-10-02 2026-04-02\n"
            "Format: YYYY-MM-DD"
        )
        return

    try:
        start_date = context.args[0]
        end_date = context.args[1]

        # Validate dates
        datetime.strptime(start_date, "%Y-%m-%d")
        datetime.strptime(end_date, "%Y-%m-%d")

        # Update database
        username = update.effective_user.username or update.effective_user.first_name
        save_subscriber(user_id, username, start_date, end_date)

        await update.message.reply_text(
            f"‚úÖ Date range updated!\n\n"
            f"Start: {start_date}\n"
            f"End: {end_date}\n\n"
            f"I'll check for appointments in this range."
        )
        logger.info(f"User {user_id} set date range: {start_date} to {end_date}")

    except ValueError:
        await update.message.reply_text(
            "‚ùå Invalid date format. Please use YYYY-MM-DD\n\n"
            "Example: /setdates 2025-10-02 2026-04-02"
        )


async def status(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle the /status command - show current status"""
    user_id = update.effective_user.id
    subscribers = load_subscribers()

    subscription_status = "‚úÖ Subscribed" if user_id in subscribers else "‚ùå Not subscribed"

    start_date, end_date = get_user_date_range(user_id, subscribers)

    last_check = stats['last_check_time']
    last_check_str = last_check.strftime("%Y-%m-%d %H:%M:%S") if last_check else "Never"

    await update.message.reply_text(
        f"üìä Your Status\n\n"
        f"Subscription: {subscription_status}\n"
        f"Date range: {start_date} to {end_date}\n"
        f"Check interval: {CHECK_INTERVAL // 60} minutes\n"
        f"Last check: {last_check_str}\n\n"
        f"Service: Notfalltermin Ausl√§nderbeh√∂rde\n"
        f"Office ID: {OFFICE_ID}\n"
        f"Service ID: {SERVICE_ID}\n\n"
        f"Total subscribers: {len(subscribers)}"
    )


async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle the /stats command - show bot statistics"""
    subscribers = load_subscribers()

    uptime = "Unknown"
    if stats['bot_start_time']:
        uptime_seconds = (datetime.now() - stats['bot_start_time']).total_seconds()
        hours = int(uptime_seconds // 3600)
        minutes = int((uptime_seconds % 3600) // 60)
        uptime = f"{hours}h {minutes}m"

    success_rate = 0
    if stats['total_checks'] > 0:
        success_rate = (stats['successful_checks'] / stats['total_checks']) * 100

    last_check = stats['last_check_time']
    last_check_str = last_check.strftime("%Y-%m-%d %H:%M:%S") if last_check else "Never"

    last_success = stats['last_success_time']
    last_success_str = last_success.strftime("%Y-%m-%d %H:%M:%S") if last_success else "Never"

    await update.message.reply_text(
        f"üìä Bot Statistics\n\n"
        f"‚è± Uptime: {uptime}\n"
        f"üë• Subscribers: {len(subscribers)}\n\n"
        f"üîç Total checks: {stats['total_checks']}\n"
        f"‚úÖ Successful: {stats['successful_checks']}\n"
        f"‚ùå Failed: {stats['failed_checks']}\n"
        f"üìà Success rate: {success_rate:.1f}%\n\n"
        f"üéØ Appointments found: {stats['appointments_found_count']} times\n\n"
        f"üïê Last check: {last_check_str}\n"
        f"‚úÖ Last successful check: {last_success_str}"
    )


async def send_health_alert(application: Application, message: str):
    """Send health check alert to admin"""
    admin_id = os.getenv("ADMIN_TELEGRAM_ID")
    if not admin_id:
        logger.warning("ADMIN_TELEGRAM_ID not set, skipping health alert")
        return

    try:
        await application.bot.send_message(
            chat_id=int(admin_id),
            text=f"‚ö†Ô∏è <b>HEALTH ALERT</b> ‚ö†Ô∏è\n\n{message}",
            parse_mode='HTML'
        )
        logger.info(f"Health alert sent to admin: {message}")
    except Exception as e:
        logger.error(f"Failed to send health alert: {e}")


async def check_and_notify(application: Application) -> None:
    """Background task to check for appointments and notify subscribers"""
    global captcha_token, token_expires_at

    consecutive_failures = 0
    MAX_CONSECUTIVE_FAILURES = 5

    while True:
        try:
            subscribers = load_subscribers()
            stats['last_check_time'] = datetime.now()
            stats['total_checks'] += 1

            # Get all service subscriptions
            service_subs = get_all_service_subscriptions()

            if not service_subs:
                logger.info("No service subscriptions, skipping check")
                await asyncio.sleep(CHECK_INTERVAL)
                continue

            # Refresh token if needed
            if time.time() >= token_expires_at:
                logger.info("Getting fresh captcha token...")
                captcha_token = get_fresh_captcha_token()
                if not captcha_token:
                    logger.error("Failed to get captcha token")
                    stats['failed_checks'] += 1
                    consecutive_failures += 1

                    if consecutive_failures >= MAX_CONSECUTIVE_FAILURES:
                        await send_health_alert(
                            application,
                            f"Bot has failed {consecutive_failures} consecutive checks!\n"
                            f"Last error: Failed to get captcha token"
                        )

                    await asyncio.sleep(CHECK_INTERVAL)
                    continue
                token_expires_at = time.time() + 280  # ~4.5 minutes
                logger.info("Got fresh token")

            # Check each unique service/office combination
            for service_office_key, user_ids in service_subs.items():
                service_id, office_id = service_office_key.split('_')
                service_id = int(service_id)
                office_id = int(office_id)

                # Get date ranges for users subscribed to this service
                date_ranges = {}
                for user_id in user_ids:
                    if user_id in subscribers:
                        start_date, end_date = get_user_date_range(user_id, subscribers)
                        key = f"{start_date}_{end_date}"
                        if key not in date_ranges:
                            date_ranges[key] = []
                        date_ranges[key].append(user_id)

                # Check each unique date range for this service
                for date_key, date_user_ids in date_ranges.items():
                    start_date, end_date = date_key.split('_')

                    # Get service name for logging
                    service_info = get_service_info(service_id)
                    service_name = service_info['name'] if service_info else f"Service {service_id}"

                    logger.info(f"Checking {service_name} (ID:{service_id}, Office:{office_id}) from {start_date} to {end_date} for {len(date_user_ids)} users")
                    data = get_available_days(start_date, end_date, captcha_token, str(office_id), str(service_id))

                # Check if appointments are available
                appointments_found = False

                if isinstance(data, dict):
                    if "errorCode" in data:
                        logger.warning(f"API error: {data['errorCode']} - {data.get('errorMessage', '')}")
                        stats['failed_checks'] += 1
                        consecutive_failures += 1
                    elif data and len(data) > 0:
                        appointments_found = True
                elif isinstance(data, list) and len(data) > 0:
                    appointments_found = True

                    if appointments_found:
                        logger.info(f"‚úÖ Appointments found for {service_name}! Notifying {len(date_user_ids)} users")
                        stats['successful_checks'] += 1
                        stats['last_success_time'] = datetime.now()
                        stats['appointments_found_count'] += 1
                        consecutive_failures = 0

                        # Log the appointment with service info
                        conn = sqlite3.connect(DB_FILE)
                        cursor = conn.cursor()
                        cursor.execute('''
                            INSERT INTO appointment_logs (found_at, service_id, office_id, data)
                            VALUES (?, ?, ?, ?)
                        ''', (datetime.now().isoformat(), service_id, office_id, json.dumps(data)))
                        conn.commit()
                        conn.close()

                        # Parse available dates/times
                        appointments_detail = format_available_appointments(data)

                        # Build booking URL
                        booking_url = f"https://stadt.muenchen.de/buergerservice/terminvereinbarung.html#/services/{service_id}/locations/{office_id}"

                        # Format the message
                        message = (
                            "üéâ <b>TERMIN VERF√úGBAR!</b> üéâ\n\n"
                            f"<b>{service_name}</b>\n\n"
                        )

                        if appointments_detail:
                            message += f"Verf√ºgbare Termine:\n{appointments_detail}\n"
                        else:
                            message += f"üìÖ Zeitraum: {start_date} bis {end_date}\n\n"

                        message += (
                            f"üîó <a href='{booking_url}'>Jetzt Termin buchen!</a>\n\n"
                            "‚ö° Schnell handeln - Termine werden schnell vergeben!"
                        )

                        # Notify all users for this date range
                        for user_id in date_user_ids:
                            try:
                                await application.bot.send_message(
                                    chat_id=user_id,
                                    text=message,
                                    parse_mode='HTML',
                                    disable_web_page_preview=False
                                )
                                logger.info(f"Notified user {user_id} about {service_name}")
                            except Exception as e:
                                logger.error(f"Failed to notify user {user_id}: {e}")
                    else:
                        logger.info(f"No appointments available for {service_name} ({start_date} to {end_date})")
                        stats['successful_checks'] += 1
                        stats['last_success_time'] = datetime.now()
                        consecutive_failures = 0

        except Exception as e:
            logger.error(f"Error in check_and_notify: {e}")
            stats['failed_checks'] += 1
            consecutive_failures += 1

            if consecutive_failures >= MAX_CONSECUTIVE_FAILURES:
                await send_health_alert(
                    application,
                    f"Bot has failed {consecutive_failures} consecutive checks!\n"
                    f"Last error: {str(e)}"
                )

        await asyncio.sleep(CHECK_INTERVAL)


async def post_init(application: Application) -> None:
    """Start background task after bot initialization"""
    stats['bot_start_time'] = datetime.now()
    asyncio.create_task(check_and_notify(application))


def main() -> None:
    """Start the bot"""
    # Initialize database
    init_database()

    # Get bot token from environment variable
    bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
    if not bot_token:
        raise ValueError(
            "TELEGRAM_BOT_TOKEN environment variable not set!\n"
            "Set it with: export TELEGRAM_BOT_TOKEN='your_token_here'"
        )

    # Import and setup bot commands
    from bot_commands import (
        start as cmd_start,
        subscribe_command,
        button_callback,
        myservices_command,
        stop as cmd_stop,
        ask_command,
        language_command,
        inject_db_functions
    )

    # Inject database functions into bot_commands
    inject_db_functions({
        'load_subscribers': load_subscribers,
        'save_subscriber': save_subscriber,
        'remove_subscriber': remove_subscriber,
        'add_service_subscription': add_service_subscription,
        'remove_service_subscription': remove_service_subscription,
        'get_user_subscriptions': get_user_subscriptions,
        'get_all_service_subscriptions': get_all_service_subscriptions,
        'get_user_language': get_user_language,
        'set_user_language': set_user_language
    })

    # Create the Application
    application = Application.builder().token(bot_token).post_init(post_init).build()

    # Register command handlers (new multi-service interface)
    application.add_handler(CommandHandler("start", cmd_start))
    application.add_handler(CommandHandler("ask", ask_command))
    application.add_handler(CommandHandler("subscribe", subscribe_command))
    application.add_handler(CommandHandler("myservices", myservices_command))
    application.add_handler(CommandHandler("language", language_command))
    application.add_handler(CommandHandler("stop", cmd_stop))
    application.add_handler(CallbackQueryHandler(button_callback))

    # Keep old commands for compatibility
    application.add_handler(CommandHandler("setdates", setdates))
    application.add_handler(CommandHandler("status", status))
    application.add_handler(CommandHandler("stats", stats_command))

    logger.info("Bot started! Multi-service subscription enabled.")

    # Load existing subscribers and subscriptions
    subscribers = load_subscribers()
    service_subs = get_all_service_subscriptions()
    logger.info(f"Loaded {len(subscribers)} users with {len(service_subs)} unique service subscriptions")

    # Run the bot
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
